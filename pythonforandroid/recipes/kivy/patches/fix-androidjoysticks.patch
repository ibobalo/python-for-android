diff --git a/doc/sources/index.rst b/doc/sources/index.rst
index 0e80d8f..e0d50ee 100644
--- a/doc/sources/index.rst
+++ b/doc/sources/index.rst
@@ -30,12 +30,12 @@ different modules, classes, functions and variables available in Kivy.
 License
 -------
 
-Kivy is released and distributed under the terms of the MIT license starting
-version 1.7.2. Older versions are still under the LGPLv3.
+Kivy 1.7.2 and 1.8 are now under MIT License. Previous version are still under
+LGPL 3 license.
 
-You should have received a copy of the MIT license alongside your Kivy
-distribution. See the LICENSE file in the Kivy root folder. An online version
-of the license can be found at:
+Kivy is released under the terms of the MIT License.  You should have received
+a copy of the MIT alongside your Kivy distribution. See the file LICENSE in the
+Kivy root folder.  An online version of the license can be found at:
 
     https://github.com/kivy/kivy/blob/master/LICENSE
 
@@ -48,5 +48,5 @@ For a list of authors, please see the file AUTHORS that accompanies the
 Kivy source code distribution (next to LICENSE).
 
 
-Kivy -- Copyright 2010-2015, The Kivy Authors.
+Kivy -- Copyright 2010-2014, The Kivy Authors. All rights reserved.
 
diff --git a/examples/android/vlc/Makefile b/examples/android/vlc/Makefile
new file mode 100644
index 0000000..56ab553
--- /dev/null
+++ b/examples/android/vlc/Makefile
@@ -0,0 +1,77 @@
+NDK_PATH=$(HOME)/android-ndk-r10c
+ADK_PATH=$(HOME)/android-sdk-linux_r23.0.2
+API=17
+PKG=org.test.NativeVlcPlayer
+LIBVLC_AAR=$(HOME)/libvlc-3.0.0.aar
+
+apk: dist
+	export ANDROIDAPI=$(API) && \
+	export ANDROIDNDK=$(NDK_PATH) && \
+	export ANDROIDSDK=$(ADK_PATH) && \
+	p4a apk \
+			--dir=$(abspath .) \
+			--dist_name=kivy-vlc-android \
+			--sdk_dir=$(ADK_PATH) \
+			--ndk_dir=$(NDK_PATH) \
+			--android_api=$(API) \
+			--package $(PKG) \
+			--version 1.0 \
+			--name "Native Vlc Player" \
+			--orientation sensor \
+			--meta-data surface.transparent=1 \
+			--meta-data surface.depth=16 \
+			--meta-data android.background_color=0
+dist:
+	export LIBVLC_AAR=$(LIBVLC_AAR) && \
+	export ANDROIDAPI=$(API) && \
+	export ANDROIDNDK=$(NDK_PATH) && \
+	export ANDROIDSDK=$(ADK_PATH) && \
+	p4a create \
+			--dist_name=kivy-vlc-android \
+			--bootstrap=pygame \
+			--requirements=kivy,vlc,android \
+			--sdk_dir=$(ADK_PATH) \
+			--ndk_dir=$(NDK_PATH) \
+			--android_api=$(API)
+.PHONY: dist_vlc
+
+#kivy 1.9 fix - downgrade cython to 0.20
+CYTHONVER=0.20
+GETTEXTVER=0.19.5.1
+install_ubuntu_requirements:
+	sudo apt-get update
+	sudo apt-get -y install \
+			build-essential ccache git make gcc python python-dev python-pip ant
+			pkg-config autoconf automake libtool \
+			unzip p7zip-full zlib1g-dev \
+			openjdk-7-jdk android-tools-adb android-tools-fastboot \
+			autoconf automake autopoint cmake gawk gcc g++ yasm libtool m4 patch \
+			pkg-config ragel subversion unzip ant acl \
+			protobuf-compiler libprotobuf-dev libprotobuf-c0-dev protobuf-c-compiler
+	if ! cython -V 2>&1|grep 'Cython version $(CYTHONVER)'; then \
+		echo y | sudo pip uninstall cython ; \
+		sudo pip install cython==$(CYTHONVER) ; \
+	fi
+	sudo pip install markupsafe
+	sudo pip install virtualenv
+	if ! gettext -V | grep $(GETTEXTVER); then \
+		wget http://ftp.gnu.org/pub/gnu/gettext/gettext-$(GETTEXTVER).tar.gz -O - | tar xz && \
+		cd gettext-$(GETTEXTVER)/ && ./configure --prefix=/usr/local && make && sudo make install && cd .. && \
+		rm -Rf gettext-$(GETTEXTVER) && \
+		echo "package gettext updated. REBOOT REQUIRED. pls start make again after reboot" && \
+		sudo reboot \
+	fi
+.PHONY: install_ubuntu_requirements
+
+ACTIVITY=org.renpy.android.PythonActivity
+test:
+	adb install -r NativeVlcPlayer-0.1-debug.pygame.apk
+	adb logcat -c
+	adb shell am start -n $(PKG)/$(ACTIVITY) -a $(ACTIVITY)
+	adb logcat | findstr /B "./python ./VLC"
+ACTIVITY_SDL2=org.kivy.android.PythonActivity
+test_sdl2:
+	adb install -r NativeVlcPlayer-0.1-debug.sdl2.apk
+	adb logcat -c
+	adb shell am start -n $(PKG)/$(ACTIVITY_SDL2) -a $(ACTIVITY_SDL2)
+	adb logcat | findstr /B "./python ./Python ./VLC ./SDL"
diff --git a/examples/android/vlc/android.txt b/examples/android/vlc/android.txt
new file mode 100644
index 0000000..601a4f4
--- /dev/null
+++ b/examples/android/vlc/android.txt
@@ -0,0 +1,6 @@
+title=Native Vlc Player
+author=Ihor Bobalo
+orientation=sensor
+modules=kivy vlc
+permissions=INTERNET
+meta-data=surface.transparent=1 surface.depth=16 android.background_color=0
diff --git a/examples/android/vlc/main.py b/examples/android/vlc/main.py
new file mode 100644
index 0000000..c1a09d1
--- /dev/null
+++ b/examples/android/vlc/main.py
@@ -0,0 +1,192 @@
+import kivy
+from select import select
+kivy.require('1.9.0')
+from kivy.app import App
+from kivy.properties import BooleanProperty, NumericProperty, StringProperty
+from kivy.uix.floatlayout import FloatLayout
+from kivy.uix.textinput import TextInput
+from kivy.uix.button import Button
+from kivy.uix.progressbar import ProgressBar
+from kivy.uix.slider import Slider
+from kivy.logger import Logger
+
+from vlcvideoview import VlcVideoView
+VlcVideoView.VlcLibOptions.append('-vvv')
+# VlcVideoView.VlcLibOptions.append('--network-caching=100')
+
+from mediastore import query_storage_video
+
+
+DEFAULT_PLAYLIST = [
+    'rtsp://184.72.239.149/vod/mp4:BigBuckBunny_115k.mov',
+]
+
+
+class VlcExampleVideoProgress(ProgressBar):
+    seek = NumericProperty(-1)
+    seekable = BooleanProperty(False)
+
+    def __init__(self, **kwargs):
+        super(VlcExampleVideoProgress, self).__init__(**kwargs)
+
+    def on_touch_down(self, touch):
+        if not self.seekable:
+            return
+        if self.collide_point(*touch.pos):
+            return
+        touch.grab(self)
+        self._update_seek(touch.x)
+        return True
+
+    def on_touch_move(self, touch):
+        if not self.seekable:
+            return
+        if touch.grab_current is not self:
+            return
+        self._update_seek(touch.x)
+        return True
+
+    def on_touch_up(self, touch):
+        if not self.seekable:
+            return
+        if touch.grab_current is not self:
+            return
+        touch.ungrab(self)
+        self.seek = -1
+        return True
+
+    def _update_seek(self, x):
+        if not self.seekable:
+            return
+        if self.width == 0:
+            return
+        x = max(self.x, min(self.right, x)) - self.x
+        self.seek = x / float(self.width)
+
+
+class VlcExampleApp(App):
+    source = StringProperty(DEFAULT_PLAYLIST[0])
+
+    def build(self):
+        Logger.info('VlcExampleApp: building...')
+        self._playlist_idx = 0
+        self._playlist_cache = None
+
+        box = FloatLayout()
+
+        self._progress = VlcExampleVideoProgress(
+            pos_hint={'x': 0.0, 'top': 0.9},
+            size_hint=(1.0, None),
+        )
+        self._progress.bind(seek=self.on_progress_seek)
+        box.add_widget(self._progress)
+
+        self._video = VlcVideoView(
+            source=self.source,
+            pos_hint={'x': 0.0, 'y': 0.0},
+            size_hint=(1.0, 0.9),
+            options={'hw-decoder': 'enable', 'network-caching': 200},
+        )
+        self._video.bind(
+            duration=self._progress.setter('max'),
+            position=self._progress.setter('value'),
+            state=self.on_video_state,
+            loaded=self.on_video_loaded,
+            eos=self.on_video_eos,
+            seekable=self.on_video_seekable,
+        )
+        box.add_widget(self._video)
+
+        self._btn_play = Button(
+            text='>',
+            pos_hint={'x': 0.0, 'top': 1.0},
+            size_hint=(0.1, 0.1)
+        )
+        self._btn_play.bind(on_press=self.on_btn_play_press)
+        box.add_widget(self._btn_play)
+
+        self._edt = TextInput(
+            text=self.source,
+            pos_hint={'x': 0.1, 'top': 1.0},
+            size_hint=(0.8, 0.1)
+        )
+        self._edt.bind(text=self.setter('source'))
+        box.add_widget(self._edt)
+
+        self._btn_next = Button(
+            text='>>',
+            pos_hint={'x': 0.9, 'top': 1.0},
+            size_hint=(0.1, 0.1)
+        )
+        self._btn_next.bind(on_press=self.on_btn_next_press)
+        box.add_widget(self._btn_next)
+
+        return box
+
+    def _show_progress(self, seekable):
+        Logger.info('VlcExampleApp: showing progress {}'.format(seekable))
+        self._progress.opacity = 0.5
+
+    def _hide_progress(self):
+        self._progress.opacity = 0.0
+
+    def on_source(self, instance, value):
+        Logger.info('VlcExampleApp: on_source: {}'.format(value))
+        self._video.source = value
+        self._video.state = 'stop'
+
+    def on_btn_play_press(self, instance):
+        Logger.info('VlcExampleApp: on_btn_play_press')
+        if self._video.state == 'play':
+            self._video.state = 'pause'
+        else:
+            self._video.state = 'play'
+
+    def on_btn_next_press(self, instance):
+        Logger.info('VlcExampleApp: on_btn_next_press')
+        self._playlist_idx = self._playlist_idx + 1
+        if self._playlist_cache is not None:
+            playlist = self._playlist_cache
+        elif self._playlist_idx < len(DEFAULT_PLAYLIST):
+            playlist = DEFAULT_PLAYLIST
+        else:
+            playlist = DEFAULT_PLAYLIST + query_storage_video()
+            self._playlist_cache = playlist
+        self._playlist_idx = self._playlist_idx % len(playlist)
+        self._edt.text = playlist[self._playlist_idx]
+
+    def on_video_loaded(self, instance, value):
+        Logger.info('VlcExampleApp: on_video_loaded {}'.format(value))
+        if value and self._video.duration > 0:
+            self._video.state = 'play'
+            self._show_progress(True)
+        else:
+            self._hide_progress()
+
+    def on_video_state(self, instance, value):
+        Logger.info('VlcExampleApp: on_video_state {}'.format(value))
+        self._btn_play.text = {
+            'play':  '||', 'pause': '|>', 'stop':  '>'}[value]
+        for w in (self._btn_next, self._edt):
+            w.disabled = (value == 'play')
+
+    def on_video_eos(self, instance, value):
+        Logger.info('VlcExampleApp: on_video_eos {}'.format(value))
+        if value:
+            self._video.state = 'stop'
+
+    def on_video_seekable(self, instance, value):
+        self._progress.seekable = value
+
+    def on_progress_seek(self, instance, value):
+        Logger.info('VlcExampleApp: on_progress_seek {}'.format(value))
+        if value >= 0.0:
+            self._video.seek(value)
+
+
+def run():
+    a = VlcExampleApp()
+    a.run()
+
+if __name__ == '__main__':
+    run()
diff --git a/examples/android/vlc/mediastore.py b/examples/android/vlc/mediastore.py
new file mode 100644
index 0000000..f03c2a4
--- /dev/null
+++ b/examples/android/vlc/mediastore.py
@@ -0,0 +1,41 @@
+__all__ = ('query_storage_video')
+
+from jnius import autoclass, cast
+
+try:
+    bootstrap = 'pygame'
+    import android.runnable
+except ImportError:
+    bootstrap = 'sdl2'
+
+if bootstrap == 'sdl2':
+    print 'WARNING: query_storage_video() stub used'
+    def query_storage_video(maxCount=None):
+        return []
+else:
+    jPythonActivity = autoclass(
+            'org.renpy.android.PythonActivity')
+    jMediaStoreVideoMedia = autoclass(
+            'android.provider.MediaStore$Video$Media')
+    jMediaStoreMediaColumns = autoclass(
+            'android.provider.MediaStore$MediaColumns')
+
+    def query_storage_video(maxCount=None):
+        cursor = jPythonActivity.mActivity.getContentResolver().query(
+                        jMediaStoreVideoMedia.EXTERNAL_CONTENT_URI,
+                        [jMediaStoreMediaColumns.DATA],
+                        None, None, None)
+        if not cursor:
+            return []
+        result = []
+        while (maxCount is None or len(res) < maxCount) and cursor.moveToNext():
+            s = cursor.getString(0)
+            result.append(s)
+        cursor.close()
+        return result
+
+def test():
+    print query_storage_video()
+    
+if __name__ == '__main__':
+    test()
diff --git a/examples/android/vlc/nativeholder.py b/examples/android/vlc/nativeholder.py
new file mode 100644
index 0000000..a558b8b
--- /dev/null
+++ b/examples/android/vlc/nativeholder.py
@@ -0,0 +1,507 @@
+'''
+android native widget integration
+=======================
+
+The goal of this widget is to integrate any android native widget
+The android component will be placed at the right pos/size of the Kivy widget,
+as an Underlay (behind the Kivy surface, not above/overlay). The widget must
+stay in the right orientation / axis-aligned, or the placement of the android
+widget will not work.
+
+Here is the settings to add in buildozer::
+
+    [app:android.meta_data]
+    surface.transluent = 1
+    surface.depth = 16
+
+.. warning::
+
+    The Kivy's Window.clearcolor will be automatically set to transparent,
+    or the widget will not be displayed at all.
+
+.. source code is based on gmap widget https://github.com/tito/kivy-gmaps
+    
+'''
+
+__all__ = (
+	'AndroidWidgetHolder',
+	'AndroidSurfaceWidget',
+	'AndroidTextureWidget',
+	'bootstrap',
+	'ACTIVITY_CLASS_NAME',
+	'run_on_ui_thread',
+	'jPythonActivity',
+)
+
+from kivy.uix.widget import Widget
+from kivy.clock import Clock
+from kivy.properties import ObjectProperty, BooleanProperty, StringProperty
+from kivy.logger import Logger
+from kivy.core.window import Window
+from jnius import autoclass, cast, PythonJavaClass, java_method
+try:
+    bootstrap = 'pygame'
+    from android.runnable import run_on_ui_thread
+except ImportError:
+    bootstrap = 'sdl2'
+
+    class Runnable(PythonJavaClass):
+
+        '''Wrapper around Java Runnable class. This class can be used to
+        schedule a call of a Python function into the PythonActivity thread.
+        '''
+
+        __javainterfaces__ = ['java/lang/Runnable']
+        __runnables__ = []
+
+        def __init__(self, func):
+            super(Runnable, self).__init__()
+            self.func = func
+
+        def __call__(self, *args, **kwargs):
+            self.args = args
+            self.kwargs = kwargs
+            Runnable.__runnables__.append(self)
+            jPythonActivity.mActivity.runOnUiThread(self)
+
+        @java_method('()V')
+        def run(self):
+            try:
+                self.func(*self.args, **self.kwargs)
+            except:
+                import traceback
+                traceback.print_exc()
+
+            Runnable.__runnables__.remove(self)
+
+    def run_on_ui_thread(f):
+        '''Decorator to create automatically a :class:`Runnable` object
+        with the function. The function will be delayed and call into the
+        Activity thread.
+        '''
+        def f2(*args, **kwargs):
+            Runnable(f)(*args, **kwargs)
+        return f2
+
+ACTIVITY_CLASS_NAME = {
+	'pygame':'org.renpy.android.PythonActivity',
+	'sdl2':'org.kivy.android.PythonActivity'
+	}[bootstrap]
+
+jPythonActivity = autoclass(ACTIVITY_CLASS_NAME)
+jLinearLayout = autoclass('android.widget.LinearLayout')
+jAbsoluteLayout = autoclass('android.widget.AbsoluteLayout')
+jLayoutParams = autoclass('android.view.ViewGroup$LayoutParams')
+jSurfaceView = autoclass("android.view.SurfaceView")
+jSurfaceHolder = autoclass('android.view.SurfaceHolder')
+jTextureView = autoclass("android.view.TextureView")
+
+if bootstrap == 'pygame':
+    class TouchListener(PythonJavaClass):
+        __javacontext__ = 'app'
+        __javainterfaces__ = [
+            'org/renpy/android/SDLSurfaceView$OnInterceptTouchListener']
+
+        def __init__(self, listener):
+            super(TouchListener, self).__init__()
+            self.listener = listener
+
+        @java_method('(Landroid/view/MotionEvent;)Z')
+        def onTouch(self, event):
+            x = event.getX(0)
+            y = event.getY(0)
+            return self.listener(x, y)
+else:
+    print 'WARNING. SDL2 build use stub for TouchListener'
+
+    class TouchListener():
+
+        def __init__(self, listener):
+            pass
+
+
+class AndroidWidgetHolder(Widget):
+
+    '''Act as a placeholder for an Android widget.
+    It will automatically add / remove the android _native_view depending if
+    the widget _native_view is set or not. The android _native_view will act
+    as an overlay, so any graphics instruction in this area will be covered
+    by the overlay.
+
+    args:
+        native_view_factory    - factory to get native view from
+        native_view_inializer  - initializer for native view
+    props:
+        ready    - widget is inited and ready for use
+    '''
+
+    ready = BooleanProperty(False)
+    _native_view = ObjectProperty(allownone=True)
+    '''Must be an Android View
+    '''
+
+    def __init__(self, native_view_factory, **kwargs):
+        # force Window clearcolor to be transparent.
+        Window.clearcolor = (0, 0, 0, 0)
+
+        self._native_view = None
+        self._native_view_factory = native_view_factory
+        self._parent_layout = None
+        self._touch_listener = TouchListener(self._on_touch_listener)
+        self._create_native_view_trigger = Clock.create_trigger(
+            self._create_native_view)
+        self._reposition_trigger = Clock.create_trigger(self._reposition_view)
+
+        # from kivy.app import App
+        # App.get_running_app().bind(on_resume=self._reorder)
+        super(AndroidWidgetHolder, self).__init__(**kwargs)
+
+        self._create_native_view_trigger()
+
+    def _get_view_bbox(self):
+        x, y = self.to_window(*self.pos)
+        w, h = self.size
+        return [int(z) for z in [x, Window.height - y - h, w, h]]
+
+    @run_on_ui_thread
+    def _create_native_view(self, *args):
+        Logger.info('NativeWidget: creating native view')
+
+        context = jPythonActivity.mActivity
+        native_view = self._native_view_factory(context)
+
+        if native_view is None:
+            Logger.info('NativeWidget: none from factory')
+            return
+
+        x, y, w, h = self._get_view_bbox()
+
+        # XXX we assume it's the default layout from main.xml
+        # It could break.
+        if bootstrap == 'pygame':
+            self._parent_layout = cast(
+                jLinearLayout, jPythonActivity.mView.getParent())
+            self._parent_layout.addView(native_view, 0, jLayoutParams(w, h))
+        elif bootstrap == 'sdl2':
+            self._parent_layout = cast(
+                jAbsoluteLayout, jPythonActivity.getLayout().getParent())
+            self._parent_layout.addView(native_view, 0, jLayoutParams(w, h))
+        else:
+            raise 'unsupported bootstap {}'.format(bootstrap)
+
+        native_view.setX(x)
+        native_view.setY(y)
+
+        Logger.info(
+            'NativeWidget: native view added (%d, %d, %d, %d)' % (x, y, w, h))
+
+        # we need to differenciate if there is interaction with our holder
+        # or not. XXX must be activated only if the _native_view is displayed
+        # on the screen!
+        if bootstrap == 'pygame':
+            jPythonActivity.mView.setInterceptTouchListener(
+                self._touch_listener)
+
+        self._native_view = native_view
+        self.ready = True
+
+    @run_on_ui_thread
+    def _reposition_view(self, *args):
+        native_view = self._native_view
+        if native_view:
+            x, y, w, h = self._get_view_bbox()
+            Logger.info('NativeWidget: {} {} repositioning to {}'.format(
+                self.pos, self.size, (x, y, w, h)))
+            params = native_view.getLayoutParams()
+            if not params:
+                Logger.info('NativeWidget: repositioning failed')
+                return
+            params.width = w
+            params.height = h
+            native_view.setLayoutParams(params)
+            native_view.setX(x)
+            native_view.setY(y)
+
+    def _remove_view(self, instance, view):
+        if self._native_view is not None:
+            # XXX probably broken
+            layout = cast(jLinearLayout, self._native_view.getParent())
+            layout.removeView(self._native_view)
+            self._native_view = None
+            Logger.info('NativeView: view removed')
+
+    def on_ready(self, instance, ready):
+        Logger.info('NativeView: on_ready()')
+        pass
+
+    def on_size(self, instance, value):
+        Logger.info('NativeWidget: on_size {}'.format(value))
+        self._reposition_trigger()
+
+    def on_pos(self, instance, value):
+        Logger.info('NativeWidget: on_pos {}'.format(value))
+        self._reposition_trigger()
+
+    #
+    # Determine if the touch is going to be for us, or for the android widget.
+    # If we find any Kivy widget behind the touch (except us), then avoid the
+    # dispatching to the map. The touch will be received by the widget later.
+    #
+
+    def _on_touch_listener(self, x, y):
+        # invert Y !
+        y = Window.height - y
+        # x, y are in Window coordinate. Try to select the widget under the
+        # touch.
+        widget = None
+        for child in reversed(Window.children):
+            widget = self._pick(child, x, y)
+            if not widget:
+                continue
+        if self is widget:
+            return True
+
+    def _pick(self, widget, x, y):
+        ret = None
+        if widget.collide_point(x, y):
+            ret = widget
+            x2, y2 = widget.to_local(x, y)
+            for child in reversed(widget.children):
+                ret = self._pick(child, x2, y2) or ret
+        return ret
+
+##########################################################################
+#
+#    for android.view.View inherited
+#
+##########################################################################
+
+
+class AndroidNativeViewWidget(Widget):
+
+    def __init__(self, **kwargs):
+        self._nativeHolder = None
+        super(AndroidNativeViewWidget, self).__init__(**kwargs)
+
+        self._nativeHolder = nativeHolder = AndroidWidgetHolder(
+            self.native_view_factory, **kwargs)
+        self.add_widget(nativeHolder)
+        self.bind(
+            size=nativeHolder.setter('size'),
+            pos=nativeHolder.setter('pos'))
+
+    def native_view_factory(self, context):
+        raise "native_view_factory(self, context)  must be defined in " \
+            "AndroidNativeViewWidget inherited classes"
+
+    def get_native_pos(self):
+        return (self._nativeHolder.x - self.x, self._nativeHolder.y - self.y)
+
+    def get_native_size(self):
+        return self._nativeHolder.size
+
+    def set_native_pos(self, pos):
+        self._nativeHolder.pos = (pos[0] + self.x, pos[1] + self.y)
+
+    def set_native_size(self, size):
+        self._nativeHolder.size = size
+
+##########################################################################
+#
+#    for android.view.SurfaceView inherited
+#
+##########################################################################
+
+
+class SurfaceHolderCallbacksRedirector(PythonJavaClass):
+
+    '''
+    Interface used to know exactly when the Surface used will be
+    created and changed.
+    '''
+    __javainterfaces__ = ['android.view.SurfaceHolder$Callback']
+    __javacontext__ = 'app'
+
+    def __init__(self, host):
+        super(SurfaceHolderCallbacksRedirector, self).__init__()
+        self._host = host
+
+    # abstract void surfaceChanged (SurfaceHolder holder, int format, int
+    # width, int height)
+    @java_method('(Landroid/view/SurfaceHolder;III)V')
+    def surfaceChanged(self, holder, fmt, width, height):
+        Logger.info('SurfaceHolderCallback: surfaceChanged')
+        try:
+            self._host.on_surface_changed(holder, fmt, width, height)
+        except AttributeError:
+            pass
+
+    # abstract void surfaceCreated (SurfaceHolder holder)
+    @java_method('(Landroid/view/SurfaceHolder;)V')
+    def surfaceCreated(self, holder):
+        Logger.info('SurfaceHolderCallback: surfaceCreated')
+        try:
+            self._host.on_surface_created(holder)
+        except AttributeError:
+            pass
+
+    # abstract void surfaceDestroyed (SurfaceHolder holder)
+    @java_method('(Landroid/view/SurfaceHolder;)V')
+    def surfaceDestroyed(self, holder):
+        Logger.info('SurfaceHolderCallback: surfaceDestroyed')
+        try:
+            self._host.on_surface_destroyed(holder)
+        except AttributeError:
+            pass
+
+
+class AndroidSurfaceWidget(AndroidNativeViewWidget):
+
+    def __init__(self, **kwargs):
+        self.surfaceView = None
+        super(AndroidSurfaceWidget, self).__init__(**kwargs)
+
+    def native_view_factory(self, context):
+        # create a fake surfaceview
+        self.surfaceView = surfaceView = jSurfaceView(context)
+        Logger.info('AndroidSurfaceWidget: surfaceView created')
+
+        # must be defined in inherited classes
+        self.populate_surface_view(surfaceView, context)
+        Logger.info('AndroidSurfaceWidget: surfaceView populated')
+
+        # set callbacks
+        self._surfaceHolderCallbacksRedirector = \
+            SurfaceHolderCallbacksRedirector(self)
+        surfaceView.getHolder().addCallback(
+            self._surfaceHolderCallbacksRedirector)
+        Logger.info('AndroidSurfaceWidget: surfaceView callbacks activated')
+
+        return surfaceView
+
+    def populate_surface_view(self, surfaceView, context):
+        raise "populate_surface_view(self, surfaceView, context)  must be " \
+            "defined in AndroidSurfaceWidget inherited classes"
+
+    def on_surface_created(self, surfaceHolder):
+        Logger.info('AndroidSurfaceWidget: _on_surface_created')
+        pass
+
+    def on_surface_changed(self, surfaceHolder, fmt, width, height):
+        # internal, called when the android SurfaceView is ready
+        Logger.info(
+            'AndroidSurfaceWidget: _on_surface_changed (%d, %d), %x' % \
+            (width, height, fmt))
+        pass
+
+    def on_surface_destroyed(self, surfaceHolder):
+        Logger.info('AndroidSurfaceWidget: _on_surface_destroyed')
+        pass
+
+##########################################################################
+#
+#    for android.view.TextureView inherited
+#
+##########################################################################
+
+
+class SurfaceTextureListenerRedirector(PythonJavaClass):
+    __javainterfaces__ = ['android/view/TextureView$SurfaceTextureListener']
+    __javacontext__ = 'app'
+
+    def __init__(self, host):
+        self._host = host
+        super(SurfaceTextureListenerRedirector, self).__init__()
+
+    # abstract void onSurfaceTextureAvailable (SurfaceTexture surface, int
+    # width, int height)
+    @java_method('(Landroid/graphics/SurfaceTexture;II)V')
+    def onSurfaceTextureAvailable(self, surfaceTexture, width, height):
+        Logger.info('SurfaceTextureListener: SurfaceTextureAvailable')
+        try:
+            self._host.on_surface_texture_available(
+                surfaceTexture, width, height)
+        except AttributeError:
+            pass
+
+    # abstract void onSurfaceTextureSizeChanged (SurfaceTexture surface, int
+    # width, int height)
+    @java_method('(Landroid/graphics/SurfaceTexture;II)V')
+    def onSurfaceTextureSizeChanged(self, surfaceTexture, width, height):
+        Logger.info('SurfaceTextureListener: SurfaceTextureSizeChanged')
+        try:
+            self._host.on_surface_texture_size_changed(
+                surfaceTexture, width, height)
+        except AttributeError:
+            pass
+
+    # abstract void onSurfaceTextureUpdated (SurfaceTexture surface)
+    @java_method('(Landroid/graphics/SurfaceTexture;)V')
+    def onSurfaceTextureUpdated(self, surfaceTexture):
+        Logger.info('SurfaceTextureListener: SurfaceTextureUpdated')
+        try:
+            self._host.on_surface_texture_updated(surfaceTexture)
+        except AttributeError:
+            pass
+
+    # abstract boolean onSurfaceTextureDestroyed (SurfaceTexture surface)
+    @java_method('(Landroid/graphics/SurfaceTexture;)Z')
+    def onSurfaceTextureDestroyed(self, surfaceTexture):
+        Logger.info('SurfaceTextureListener: SurfaceTextureDestroyed')
+        if self._onSurfaceTextureDestroyedCallback:
+            return self._onSurfaceTextureDestroyedCallback(surfaceTexture)
+        try:
+            self._host.on_surface_texture_destroyed(surfaceTexture)
+        except AttributeError:
+            pass
+        return True
+
+
+class AndroidTextureWidget(AndroidNativeViewWidget):
+
+    def __init__(self, **kwargs):
+        self.textureView = None
+        super(AndroidTextureWidget, self).__init__(**kwargs)
+
+    def native_view_factory(self, context):
+        # Create a fake TextureView
+        self.textureView = textureView = jTextureView(context)
+
+        self.populate_texture_view(textureView, context)
+
+        # set callbacks
+        self._surfaceTextureListenerRedirector = \
+            SurfaceTextureListenerRedirector(
+                onSurfaceTextureAvailable=self.on_texture_available,
+                onSurfaceTextureSizeChangedCallback=self.on_texture_resize,
+                onSurfaceTextureUpdatedCallback=self.on_texture_update,
+                onSurfaceTextureDestroyedCallback=self.on_texture_destroy,
+            )
+        textureView.setSurfaceTextureListener(
+            self._surfaceTextureListenerRedirector)
+        return textureView
+
+    def populate_texture_view(self, textureView, context):
+        raise "populate_texture_view(self, textureView, context)  must be " \
+            "defined in AndroidTextureWidget child classes"
+
+    def on_texture_available(self, surfaceTexture, width, height):
+        Logger.info(
+            'AndroidTextureWidget: on_texture_available (%d, %d)' % \
+            (width, height))
+        pass
+
+    def on_texture_resize(self, surfaceTexture, width, height):
+        Logger.info(
+            'AndroidTextureWidget: on_texture_resize (%d, %d)' % \
+            (width, height))
+        pass
+
+    def on_texture_update(self, surfaceTexture):
+        Logger.info('AndroidTextureWidget: on_texture_update')
+        pass
+
+    def on_texture_destroy(self, surfaceTexture):
+        Logger.info('AndroidTextureWidget: on_texture_destroy')
+        self.destroy_video_player(surfaceTexture)
+        pass
diff --git a/examples/android/vlc/vlcvideoview.py b/examples/android/vlc/vlcvideoview.py
new file mode 100644
index 0000000..d9b08aa
--- /dev/null
+++ b/examples/android/vlc/vlcvideoview.py
@@ -0,0 +1,635 @@
+'''
+android VLC MediaPlayer integration
+=======================
+
+The goal of this widget is to integrate VLC MediaPlayer widget
+
+'''
+__all__ = ('VlcVideoView', 'VlcOptions')
+
+from nativeholder import AndroidSurfaceWidget, run_on_ui_thread
+
+from kivy.clock import Clock
+from kivy.properties import BooleanProperty, StringProperty,
+        OptionProperty, NumericProperty, DictProperty, ReferenceListProperty
+from kivy.logger import Logger
+
+from jnius import autoclass, cast, PythonJavaClass, java_method
+
+jLibVLC = autoclass('org.videolan.libvlc.LibVLC')
+jVlcUtil = autoclass('org.videolan.libvlc.util.VLCUtil')
+jVlcVOut = autoclass('org.videolan.libvlc.IVLCVout')
+jVlcMediaPlayer = autoclass('org.videolan.libvlc.MediaPlayer')
+jVlcMediaPlayerEvent = autoclass('org.videolan.libvlc.MediaPlayer$Event')
+jVlcMedia = autoclass('org.videolan.libvlc.Media')
+jVlcMediaEvent = autoclass('org.videolan.libvlc.Media$Event')
+jVlcMediaMeta = autoclass('org.videolan.libvlc.Media$Meta')
+jVlcMediaList = autoclass('org.videolan.libvlc.MediaList')
+jArrayList = autoclass('java.util.ArrayList')
+jTextUtils = autoclass('android.text.TextUtils')
+jString = autoclass('java.lang.String')
+jUri = autoclass('android.net.Uri')
+
+########################
+#
+#   event listeners
+#
+########################
+
+
+class VlcHardwareAccelerationError(PythonJavaClass):
+    __javainterfaces__ = [
+        'org/videolan/libvlc/LibVLC$HardwareAccelerationError']
+    __javacontext__ = 'app'
+
+    def __init__(self):
+        self._hosts = []
+        super(VlcHardwareAccelerationError, self).__init__()
+
+    def add_observer(self, host):
+        self._hosts.append(host)
+
+    def remove_observer(self, host):
+        self._hosts.remove(host)
+
+    # abstract void eventHardwareAccelerationError()
+    @java_method('()V')
+    def eventHardwareAccelerationError(self):
+        for host in self._hosts:
+            host.on_vlc_hw_error()
+
+
+class VlcMediaEventsRedirector(PythonJavaClass):
+    __javainterfaces__ = ['org/videolan/libvlc/Media$EventListener']
+    __javacontext__ = 'app'
+
+    def __init__(self, host):
+        self.defaultRedirection = ('other', host.on_vlcmedia_event)
+        self.eventTypesRedirectionMap = {
+            jVlcMediaEvent.MetaChanged:
+                    ('meta_changed',
+                     host.on_vlcmedia_meta_changed),
+            jVlcMediaEvent.SubItemAdded:
+                    ('sub_item_added',
+                     host.on_vlcmedia_sub_item_added),
+            jVlcMediaEvent.DurationChanged:
+                    ('duration_changed',
+                     host.on_vlcmedia_duration_changed),
+            jVlcMediaEvent.ParsedChanged:
+                    ('parsed_changed',
+                     host.on_vlcmedia_parsed_changed),
+            jVlcMediaEvent.StateChanged:
+                    ('state_changed',
+                     host.on_vlcmedia_state_changed),
+            jVlcMediaEvent.SubItemTreeAdded:
+                    ('sub_item_tree_added',
+                     host.on_vlcmedia_sub_item_tree_added),
+        }
+        super(VlcMediaEventsRedirector, self).__init__()
+
+    # abstract void onEvent(Media.Event event)
+    @java_method('(Lorg/videolan/libvlc/VLCEvent;)V')
+    def onEvent(self, event):
+        name, redirection = self.eventTypesRedirectionMap.get(
+            event.type, self.defaultRedirection)
+        Logger.info("VlcVideoView: Media event %d %s" % (event.type, name))
+        mediaEvent = cast('org/videolan/libvlc/Media$Event', event)
+        redirection(mediaEvent)
+
+
+class VlcMediaPlayerEventsRedirector(PythonJavaClass):
+    __javainterfaces__ = ['org/videolan/libvlc/MediaPlayer$EventListener']
+    __javacontext__ = 'app'
+
+    def __init__(self, host):
+        self.defaultRedirection = ('other', host.on_vlcplayer_event)
+        self.eventTypesRedirectionMap = {
+            jVlcMediaPlayerEvent.Opening:
+                    ('opening', host.on_vlcplayer_opening),
+            # jVlcMediaPlayerEvent.Buffering: 
+            #         ('buffering', host.on_vlcplayer_buffering),
+            jVlcMediaPlayerEvent.Playing:
+                    ('playing', host.on_vlcplayer_playing),
+            jVlcMediaPlayerEvent.Paused:
+                    ('paused', host.on_vlcplayer_paused),
+            jVlcMediaPlayerEvent.Stopped:
+                    ('stopped', host.on_vlcplayer_stopped),
+            # jVlcMediaPlayerEvent.Forward:
+            #         ('forward', host.on_vlcplayer_forward),
+            # jVlcMediaPlayerEvent.Backward:
+            #         ('backward', host.on_vlcplayer_backward),
+            jVlcMediaPlayerEvent.EndReached:
+                    ('end_reached',
+                     host.on_vlcplayer_end_reached),
+            jVlcMediaPlayerEvent.EncounteredError:
+                    ('error', host.on_vlcplayer_error),
+            jVlcMediaPlayerEvent.TimeChanged:
+                    ('time', host.on_vlcplayer_time),
+            jVlcMediaPlayerEvent.PositionChanged:
+                    ('position', host.on_vlcplayer_position),
+            jVlcMediaPlayerEvent.SeekableChanged:
+                    ('seekable', host.on_vlcplayer_seekable),
+            jVlcMediaPlayerEvent.PausableChanged:
+                    ('pausable', host.on_vlcplayer_pausable),
+            # jVlcMediaPlayerEvent.TitleChanged:
+            #         ('title', host.on_vlcplayer_title),
+            # jVlcMediaPlayerEvent.SnapshotTaken:
+            #         ('snapshot', host.on_vlcplayer_snapshot),
+            # jVlcMediaPlayerEvent.LengthChanged:
+            #         ('length', host.on_vlcplayer_length),
+            jVlcMediaPlayerEvent.Vout:
+                    ('vout', host.on_vlcplayer_vout),
+            # jVlcMediaPlayerEvent.ScrambleChanged:
+            #         ('scramble', host.on_vlcplayer_scramble),
+            jVlcMediaPlayerEvent.ESAdded:
+                    ('es_added', host.on_vlcplayer_es_added),
+            jVlcMediaPlayerEvent.ESDeleted:
+                    ('es_deleted', host.on_vlcplayer_es_deleted),
+            # jVlcMediaPlayerEvent.ESSelected:
+            #         ('es_selected', host.on_vlcplayer_es_selected),
+        }
+        super(VlcMediaPlayerEventsRedirector, self).__init__()
+
+    # abstract void onEvent(MediaPlayer.Event event)
+    @java_method('(Lorg/videolan/libvlc/VLCEvent;)V')
+    def onEvent(self, event):
+        name, redirection = self.eventTypesRedirectionMap.get(
+            event.type, self.defaultRedirection)
+        Logger.info("VlcVideoView: Player event %d %s" % (event.type, name))
+        mediaPlayerEvent = cast('org/videolan/libvlc/MediaPlayer$Event', event)
+        redirection(mediaPlayerEvent)
+
+
+class VlcVOutEventsRedirector(PythonJavaClass):
+    __javainterfaces__ = ['org/videolan/libvlc/IVLCVout$Callback']
+    __javacontext__ = 'app'
+
+    def __init__(self, host):
+        self._host = host
+        super(VlcVOutEventsRedirector, self).__init__()
+    # void onNewLayout(IVLCVout vlcVout, int width, int height, int
+    # visibleWidth, int visibleHeight, int sarNum, int sarDen)
+
+    @java_method('(Lorg/videolan/libvlc/IVLCVout;IIIIII)V')
+    def onNewLayout(self, vlcVout, width, height, visibleWidth, visibleHeight,
+            sarNum, sarDen):
+        Logger.info("VlcVideoView: Vout new layout width={}, height={}, "
+            "visibleWidth={}, visibleHeight={}, sarNum={}, sarDen={}".format(
+            width, height, visibleWidth, visibleHeight, sarNum, sarDen))
+        self._host.on_vlcvout_new_layout(
+            width, height, visibleWidth, visibleHeight, sarNum, sarDen)
+    # void onSurfacesCreated(IVLCVout vlcVout)
+
+    @java_method('(Lorg/videolan/libvlc/IVLCVout;)V')
+    def onSurfacesCreated(self, vlcVout):
+        Logger.info("VlcVideoView: Vout surface created")
+        self._host.on_vlcvout_surface_created()
+    # void onSurfacesDestroyed(IVLCVout vlcVout)
+
+    @java_method('(Lorg/videolan/libvlc/IVLCVout;)V')
+    def onSurfacesDestroyed(self, vlcVout):
+        Logger.info("VlcVideoView: Vout surface destroyed")
+        self._host.on_vlcvout_surface_destroyed()
+
+########################
+#
+#  VlcVideoView
+#
+########################
+
+
+class VlcVideoView(AndroidSurfaceWidget):
+
+    '''android vlc VideoView widget
+    args:
+        source  -  path or uri to video data
+        options -  extra options 
+        state   - 'play', 'stop', 'pause'
+    props:
+        loaded   - media file is loaded and ready to go
+        duration - duration of the video. The duration defaults to -1, and is
+                   set to a real duration when the video is loaded
+        position - Position of the video between 0 and duration. The position
+                   defaults to -1 and is set to a real position when the video
+                   is loaded
+        eos      - Boolean, indicates whether the video has finished playing
+                   or not (reached the end of the stream)
+        state    - indicates whether to play, pause, or stop the video
+        player_state - indicates whether to play, pause, or stop the video
+        media_state  - indicates whether to play, pause, or stop the video
+    '''
+    loaded = BooleanProperty(False)
+    source = StringProperty()
+    options = DictProperty()
+    source_options = ReferenceListProperty(source, options)
+    state = OptionProperty('stop', options=['stop', 'play', 'pause'])
+    player_state = OptionProperty(
+        'stop', options=['stop', 'opening', 'play', 'pause', 'error'])
+    media_state = OptionProperty('nothing', options=[
+                                 'nothing', 'opening', 'buffering', 'playing',
+                                 'paused', 'stopped', 'ended', 'error'])
+    duration = NumericProperty(-1)
+    position = NumericProperty(-1)
+    position_normalized = NumericProperty(0.0)
+    eos = BooleanProperty(False)
+    seekable = BooleanProperty(False)
+    pausable = BooleanProperty(False)
+    aspect_ratio = NumericProperty(0)
+    libVLC = None
+    _hardwareAccelerationError = VlcHardwareAccelerationError()
+    VlcLibOptions = ['--noaudio']
+
+    def __init__(self, **kwargs):
+        if VlcVideoView.libVLC is None:
+            # Create singleton global LibVLC instance
+            optionsArray = jArrayList()
+            for o in VlcVideoView.VlcLibOptions:
+                optionsArray.add(o)
+            VlcVideoView.libVLC = jLibVLC(optionsArray)
+            VlcVideoView.libVLC.setOnHardwareAccelerationError(
+                VlcVideoView._hardwareAccelerationError)
+        VlcVideoView._hardwareAccelerationError.add_observer(self)
+        self._mediaObj = None
+        self._mediaPlayer = None
+        self._vlcMediaEventsRedirector = VlcMediaEventsRedirector(self)
+        self._mediaPlayerEventsRedirector = VlcMediaPlayerEventsRedirector(
+            self)
+        self._vOutCallbacks = VlcVOutEventsRedirector(self)
+
+        self._create_player()
+
+        super(VlcVideoView, self).__init__(**kwargs)
+
+    def __del__(self, **kwargs):
+        VlcVideoView._hardwareAccelerationError.remove_observer(self)
+
+    def populate_surface_view(self, surfaceView, context):
+        Logger.info('VlcVideoView: creating video view %s (%s)' %
+                    (self.source, self.state))
+
+        cpuOk = jVlcUtil.hasCompatibleCPU(context)
+        Logger.info("VlcVideoView: cpu compatible %s" % str(cpuOk))
+
+        Logger.info('VlcVideoView: populate done %s (%s)' %
+                    (self.source, self.state))
+
+    def _create_player(self):
+        #         // Create a VLC Media Player
+        self._mediaPlayer = mediaPlayer = jVlcMediaPlayer(VlcVideoView.libVLC)
+        mediaPlayer.setEventListener(self._mediaPlayerEventsRedirector)
+
+    def _unload_player(self):
+        if not self._mediaPlayer is None:
+            Logger.info('VlcVideoView: destroying %s (%s)' %
+                        (self.source, self.state))
+            self._mediaPlayer.stop()
+            self._mediaPlayer.setEventListener(None)
+            self._mediaPlayer.release()
+            self._mediaPlayer = None
+
+    def _create_media(self):
+        # Create a VLC Media object
+        if any(self.source.startswith(prefix) for prefix in [
+                    'rtsp://', 'http://', 'https://', 'file://']):
+            uri = jUri.parse(self.source)
+            self._mediaObj = jVlcMedia(VlcVideoView.libVLC, uri)
+            Logger.info('VlcVideoView: uri %s (%s)' %
+                        (self.source, self.state))
+        else:
+            self._mediaObj = jVlcMedia(VlcVideoView.libVLC, self.source)
+            Logger.info('VlcVideoView: path %s (%s)' %
+                        (self.source, self.state))
+        if self.options:
+            if self.options.has_key('network-caching'):
+                self._mediaObj.setHWDecoderEnabled(True, False)
+                Logger.info(
+                    "VlcVideoView: HWDecoder enabled by network-caching")
+            for n, v in self.options.items():
+                if n == 'hw-decoder':
+                    hw_enable = (v in ['force', 'enable', '1', 'True'])
+                    hw_force = v in ['force']
+                    self._mediaObj.setHWDecoderEnabled(hw_enable, hw_force)
+                    Logger.info(
+                        "VlcVideoView: HWDecoder enabled {}, forced {}".format(
+                        hw_enable, hw_force))
+                else:
+                    s = ':{}={}'.format(n, v) if v else ':{}'.format(n)
+                    Logger.info("VlcVideoView: Media option {}".format(s))
+                    self._mediaObj.addOption(s)
+        self._mediaObj.setEventListener(self._vlcMediaEventsRedirector)
+
+    def _unload_media(self):
+        if self._mediaObj is not None:
+            Logger.info(
+                'VlcVideoView: clearing previous source (%s)' % self.state)
+            self._mediaObj.setEventListener(None)
+            self._mediaPlayer.setMedia(None)
+            self._mediaObj = None
+            self.loaded = False
+            self.duration = -1
+            self.position = -1
+            self.position_normalized = 0.0
+            self.eos = False
+            self.seekable = False
+            self.pausable = False
+            self.player_state = 'stop'
+
+    def _attach_vout(self, surface, surfaceHolder):
+        vlcVOut = self._mediaPlayer.getVLCVout()
+        vlcVOut.setVideoSurface(surface, surfaceHolder)
+        vlcVOut.addCallback(self._vOutCallbacks)
+        vlcVOut.attachViews()
+
+    def _detach_vout(self):
+        vlcVOut = self._mediaPlayer.getVLCVout()
+        vlcVOut.dettachViews()
+        vlcVOut.removeCallback(self._vOutCallbacks)
+#         self._mediaPlayer.setVideoTrack(-1);
+
+    @run_on_ui_thread
+    def _apply_aspect_ratio(self):
+        aspect_ratio = self.aspect_ratio
+        if not self.surfaceView or not aspect_ratio:
+            return
+        width, height = self.size
+        left, top = self.get_native_pos()
+        Logger.info('VlcVideoView: aspect_ratio %.2f, sv_pos %d,%d '
+                ' size %d,%d' % (aspect_ratio, left, top, width, height))
+        adjusted_width = int(height * aspect_ratio)
+        adjusted_height = int(width / aspect_ratio)
+        if adjusted_width < width:
+            left = int((width - adjusted_width) / 2)
+            top = 0
+            width = adjusted_width
+            Logger.info('VlcVideoView: aspect ratio %.2f, '
+                'decrease width to %d, changed left to %d' % (
+                aspect_ratio, width, left))
+        elif adjusted_height < height:
+            left = 0
+            top = int((height - adjusted_height) / 2)
+            height = adjusted_height
+            Logger.info('VlcVideoView: aspect ratio %.2f, '
+                'decrease height to %d, changed top to %d' % (
+                aspect_ratio, adjusted_height, top))
+        else:
+            Logger.info('VlcVideoView: aspect ratio %.2f, '
+                'ignored %d %d to %d %d' % (
+                aspect_ratio, width, left, adjusted_width, adjusted_height))
+            return
+        self.set_native_pos((left, top))
+        self.set_native_size((width, height))
+
+    def _apply_video_player_state(self):
+        if not self._mediaPlayer:
+            Logger.info(
+                'VlcVideoView: waiting for Mediaplayer %s (%s)' % (
+                self.source, self.state))
+        elif not self._mediaPlayer.getVLCVout().areViewsAttached():
+            Logger.info('VlcVideoView: waiting for Vout %s (%s)' %
+                        (self.source, self.state))
+            self._mediaPlayer.stop()
+#             self._mediaPlayer.setVideoTrack(-1);
+        elif self.state == 'play':
+            self._select_videotrack()
+            Logger.info('VlcVideoView: starting %s (%s)' %
+                        (self.source, self.state))
+            self._mediaPlayer.play()
+        elif self.state == 'pause':
+            Logger.info('VlcVideoView: pausing %s (%s)' %
+                        (self.source, self.state))
+            self._mediaPlayer.pause()
+        else:
+            Logger.info('VlcVideoView: stopping %s (%s)' %
+                        (self.source, self.state))
+            self._mediaPlayer.stop()
+
+    def _select_videotrack(self):
+        videoTrack = self.options.get('video-track', '')
+        if videoTrack:
+            Logger.info('VlcVideoView: selecting track %d for %s' %
+                        (int(videoTrack), self.source))
+            self._mediaPlayer.setVideoTrack(int(videoTrack))
+
+    def unload(self):
+        Logger.info('VlcVideoView: unload %s' % self.source)
+        self._unload_media()
+        self._unload_player()
+
+    def seek(self, position_normalized):
+        Logger.info('VlcVideoView: seek {} for {}'.format(
+            position_normalized, self.source))
+        self._mediaPlayer.setPosition(position_normalized)
+
+    def on_source_options(self, instance, value):
+        Logger.info('VlcVideoView: on_source_options {}'.format(value))
+        self._unload_media()
+        self._create_media()
+        self._mediaPlayer.setMedia(self._mediaObj)
+
+    def on_state(self, instance, state):
+        Logger.info(
+            'VlcVideoView: on_state {} for {}'.format(state, self.source))
+        self._apply_video_player_state()
+
+    def on_size(self, instance, size):
+        Logger.info(
+            'VlcVideoView: on_size {} for {}'.format(size, self.source))
+        self._apply_aspect_ratio()
+
+    def on_aspect_ratio(self, instance, aspect_ratio):
+        Logger.info(
+            'VlcVideoView: on_aspect_ratio {} for {}'.format(
+            aspect_ratio, self.source))
+        self._apply_aspect_ratio()
+
+    #
+    # surface callbacks
+    #
+    def on_surface_created(self, surfaceHolder):
+        Logger.info('VlcVideoView: on_surface_created %s (%s)' %
+                    (self.source, self.state))
+        self._attach_vout(surfaceHolder.getSurface(), surfaceHolder)
+        self._apply_video_player_state()
+
+    def on_surface_changed(self, surfaceHolder, fmt, width, height):
+        # internal, called when the android SurfaceView is ready
+        Logger.info('VlcVideoView: on_surface_changed (%d, %d) for %s (%s)' % (
+            width, height, self.source, self.state))
+        self._apply_aspect_ratio()
+
+    def on_surface_destroyed(self, surfaceHolder):
+        Logger.info('VlcVideoView: on_surface_destroyed %s (%s)' %
+                    (self.source, self.state))
+        self._detach_vout()
+        self._apply_video_player_state()
+
+    #
+    # vlc callbacks
+    #
+    def on_vlc_hw_error(self, mediaPlayerEvent):
+        errorMessage = jVlcUtil.getErrorMsg()
+        Logger.info(
+            'VlcVideoView: on_vlc_hw_error {} for {}'.format(
+            errorMessage, self.source))
+        self.player_state = 'error'
+
+    def on_vlcplayer_event(self, mediaPlayerEvent):
+        pass
+
+    def on_vlcplayer_opening(self, mediaPlayerEvent):
+        self.player_state = 'opening'
+
+    def on_vlcplayer_playing(self, mediaPlayerEvent):
+        self.player_state = 'play'
+        self.eos = False
+
+    def on_vlcplayer_paused(self, mediaPlayerEvent):
+        self.player_state = 'pause'
+
+    def on_vlcplayer_stopped(self, mediaPlayerEvent):
+        self.player_state = 'stop'
+
+    def on_vlcplayer_end_reached(self, mediaPlayerEvent):
+        self.eos = True
+        Logger.info('VlcVideoView: on_vlcplayer_end_reached for {}'.format(
+            self.source))
+
+    def on_vlcplayer_error(self, mediaPlayerEvent):
+        errorMessage = jVlcUtil.getErrorMsg()
+        Logger.info(
+            'VlcVideoView: on_vlcplayer_error {} for {}'.format(
+            errorMessage, self.source))
+        self.player_state = 'error'
+        self.eos = True
+
+    def on_vlcplayer_vout(self, mediaPlayerEvent):
+        c = mediaPlayerEvent.getVoutCount()
+        Logger.info(
+            'VlcVideoView: on_vlc_time {} for {}'.format(c, self.source))
+
+    def on_vlcplayer_time(self, mediaPlayerEvent):
+        self.position = mediaPlayerEvent.getTimeChanged()
+        Logger.info('VlcVideoView: on_vlc_time {}(ms) of {}(ms) for {}'.format(
+            self.position, self.duration, self.source))
+
+    def on_vlcplayer_position(self, mediaPlayerEvent):
+        self.position_normalized = mediaPlayerEvent.getPositionChanged()
+        Logger.info('VlcVideoView: on_vlc_position {} for {}'.format(
+            self.position_normalized, self.source))
+
+    def on_vlcplayer_seekable(self, mediaPlayerEvent):
+        self.seekable = mediaPlayerEvent.getSeekable()
+        Logger.info('VlcVideoView: on_vlcplayer_seekable {} for {}'.format(
+            self.position_normalized, self.source))
+
+    def on_vlcplayer_pausable(self, mediaPlayerEvent):
+        self.pausable = mediaPlayerEvent.getPausable()
+        Logger.info('VlcVideoView: on_vlcplayer_pausable {} for {}'.format(
+            self.position_normalized, self.source))
+
+    def on_vlcplayer_es_added(self, mediaPlayerEvent):
+        self._select_videotrack()
+        self._log_media_tracks()
+
+    def on_vlcplayer_es_deleted(self, mediaPlayerEvent):
+        self._log_media_info()
+
+    def on_vlcmedia_event(self, mediaEvent):
+        pass
+
+    def on_vlcmedia_meta_changed(self, mediaEvent):
+        self._log_media_info()
+
+    def on_vlcmedia_sub_item_added(self, mediaEvent):
+        self._log_media_info()
+
+    def on_vlcmedia_duration_changed(self, mediaEvent):
+        self.duration = self._mediaObj.getDuration()
+        Logger.info('VlcVideoView: on_vlcmedia_duration_changed '
+            '{} for {}'.format(self.duration, self.source))
+        self._log_media_info()
+
+    def on_vlcmedia_parsed_changed(self, mediaEvent):
+        Logger.info('VlcVideoView: on_vlcmedia_parsed_changed %s' %
+                    self.source)
+        self.duration = self._mediaObj.getDuration()
+        self.loaded = bool(self._mediaObj.isParsed())
+        self._log_media_info()
+
+    def on_vlcmedia_state_changed(self, mediaEvent):
+        state = self._mediaObj.getState()
+        self.media_state = self.MediaStates.get(state, 'error')
+        Logger.info('VlcVideoView: on_vlcmedia_state_changed {} {}'.format(
+            state, self.media_state))
+
+    def on_vlcmedia_sub_item_tree_added(self, mediaEvent):
+        Logger.info(
+            'VlcVideoView: on_vlc_media_sub_item_tree_added %s' % self.source)
+
+    def on_vlcvout_new_layout(self, width, height, visibleWidth,
+            visibleHeight, sarNum, sarDen):
+        self.aspect_ratio = float(width) / float(height)
+
+    def on_vlcvout_surface_created(self):
+        pass
+
+    def on_vlcvout_surface_destroyed(self):
+        pass
+
+    MediaStates = {
+        0: 'nothing',
+        1: 'opening',
+        2: 'buffering',
+        3: 'playing',
+        4: 'paused',
+        5: 'stopped',
+        6: 'ended',
+        7: 'error',
+    }
+    MediaTypeNames = {
+        0: 'Unknown',
+        1: 'File',
+        2: 'Directory',
+        3: 'Disc',
+        4: 'Stream',
+        5: 'Playlist',
+    }
+    TrackTypeNames = {
+        - 1: 'Unknown',
+        0: 'Audio',
+        1: 'Video',
+        2: 'Text',
+    }
+
+    def _log_media_meta(self):
+        for name, meta_id in [
+            ('Title', jVlcMediaMeta.Title),
+            ('Artist', jVlcMediaMeta.Artist),
+            ('Descr', jVlcMediaMeta.Description),
+            ('Data', jVlcMediaMeta.Date),
+        ]:
+            meta = self._mediaObj.getMeta(meta_id)
+            if meta is not None:
+                Logger.info(
+                    'VlcVideoView: Media: Meta.{}: {}'.format(name, meta))
+
+    def _log_media_tracks(self):
+        for trackN in xrange(0, self._mediaObj.getTrackCount()):
+            track = self._mediaObj.getTrack(trackN)
+            Logger.info('VlcVideoView: Track[{}].type: {} ({}), id: {}, '
+                     'codec: {}, bitrate: {}, lang: {}, descr: {}'.format(
+                     trackN, self.TrackTypeNames.get(track.type, '?'),
+                     track.type, track.id, track.codec, track.bitrate,
+                     track.language, track.description))
+
+    def _log_media_info(self):
+        Logger.info('VlcVideoView: MediaInfo for {} State: {} ({}) Type: {} '
+            '({}) Parsed: {} Duration: {} Tracks: {}'.format(
+            self.source,
+            self.MediaStates.get(
+                self._mediaObj.getState(), ''), self._mediaObj.getState(),
+            self.MediaTypeNames.get(
+                self._mediaObj.getType(), ''), self._mediaObj.getType(),
+            self._mediaObj.isParsed(),
+            self._mediaObj.getDuration(),
+            self._mediaObj.getTrackCount()))
diff --git a/kivy/input/providers/androidjoystick.py b/kivy/input/providers/androidjoystick.py
index caf0c06..c5037a8 100644
--- a/kivy/input/providers/androidjoystick.py
+++ b/kivy/input/providers/androidjoystick.py
@@ -12,6 +12,7 @@ information, please refer to
 __all__ = ('AndroidMotionEventProvider', )
 
 import os
+from fnmatch import fnmatch
 
 try:
     import android  # NOQA
@@ -49,13 +50,18 @@ class AndroidMotionEventProvider(MotionEventProvider):
         self.window = None
 
     def create_joystick(self, index):
-        Logger.info('Android: create joystick <%d>' % index)
         js = pygame.joystick.Joystick(index)
+        if not fnmatch(js.get_name(), "Private pointer:*"):
+             Logger.info('Android: discard joystick <%d> cause name not matched' %
+                         index)
+             return
         js.init()
-        if js.get_numbuttons() == 0:
-            Logger.info('Android: discard joystick <%d> cause no button' %
+        if js.get_numbuttons() == 0 or js.get_numaxes() < 2:
+            Logger.info('Android: discard joystick <%d> cause no button/axes' %
                         index)
+            js.quit()
             return
+        Logger.info('Android: create joystick <%d>' % index)
         self.joysticks.append(js)
 
     def start(self):
@@ -65,7 +71,9 @@ class AndroidMotionEventProvider(MotionEventProvider):
             self.create_joystick(i)
 
     def stop(self):
+        for joy in self.joysticks: joy.quit()
         self.joysticks = []
+        pygame.joystick.quit()
 
     def update(self, dispatch_fn):
         if not self.window:
